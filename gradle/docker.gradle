import groovy.time.*

/**
 * Utility to build docker images based in gradle projects
 *
 * This extends gradle's 'application' plugin logic with a 'distDocker' task which builds
 * a docker image from the Dockerfile of the project that applies this file. The image
 * is automatically tagged and pushed if a tag and/or a registry is given.
 *
 * Parameters that can be set on project level:
 * - dockerImageName (required): The name of the image to build (e.g. controller)
 * - dockerRegistry (optional): The registry to push to
 * - dockerImageTag (optional, default 'latest'): The tag for the image
 * - dockerImagePrefix (optional, default 'whisk'): The prefix for the image,
 *       'controller' becomes 'whisk/controller' per default
 * - dockerTimeout (optional, default 840): Timeout for docker operations in seconds
 * - dockerRetries (optional, default 3): How many times to retry docker operations
 * - dockerBinary (optional, default 'docker'): The binary to execute docker commands
 * - dockerBuildArgs (options, default ''): Project specific custom docker build arguments
 * - dockerHost (optional): The docker host to run commands on, default behaviour is
 *       docker's own DOCKER_HOST environment variable
 * - dockerArch (optional): An alternate architecture to generate in Docker.  The script
 *       will expect to see a Dockerfile.dockerArch (e.g. Dockerfile.s390x) or a patch
 *       file to be applied to the Dockerfile to create the new architecture.
 */

def detectDockerArch() {
  def stdout = new ByteArrayOutputStream()
  exec {
    executable '/bin/bash'
    args '-c', "docker info 2>/dev/null | sed -n 's/Architecture: \\(.*\\)/\\1/p'"
    standardOutput = stdout;
  }
  def arch = stdout.toString().trim()
  // println "Docker architecture ${arch} detected"
  return arch
}

ext {
    dockerRegistry = project.hasProperty('dockerRegistry') ? dockerRegistry + '/' : ''
    dockerImageTag = project.hasProperty('dockerImageTag') ? dockerImageTag : 'latest'
    dockerImagePrefix = project.hasProperty('dockerImagePrefix') ? dockerImagePrefix : 'whisk'
    dockerTimeout = project.hasProperty('dockerTimeout') ? dockerTimeout.toInteger() : 840
    dockerRetries = project.hasProperty('dockerRetries') ? dockerRetries.toInteger() : 3
    dockerBinary = project.hasProperty('dockerBinary') ? [dockerBinary] : ['docker']
    dockerBuildArg = ['build']
    dockerArch = project.hasProperty('dockerArch') ? dockerArch : detectDockerArch()
}
ext.dockerTaggedImageName = dockerRegistry + dockerImagePrefix + '/' + dockerImageName + ':' + dockerImageTag

if(project.hasProperty('dockerHost')) {
    dockerBinary += ['--host', project.dockerHost]
}

if(project.hasProperty('dockerBuildArgs')) {
    dockerBuildArgs.each { arg  ->
        dockerBuildArg += ['--build-arg', arg]
    }
}

task m4Dockerfile (type: Exec) {
  def m4_args = [
    '-D', dockerArch.toUpperCase(),
    '-D', "m4_dockerarch=${dockerArch}"
  ]
  executable '/bin/sh'
  def m4_cmd = "m4 ${m4_args.join(' ')} -P Dockerfile.m4 >Dockerfile"
  args '-c', m4_cmd
  doLast {
    println m4_cmd
  }
}

// TODO: To be properly Gradle-ish, we should be doing this in a build directory
//       for all Dockerfiles.  Then we don't have to sweat cleaning up later.
task templateDockerfile (type: Copy) {
  def directory = project.buildscript.sourceFile.getParentFile()
  from directory
  into directory
  include 'Dockerfile.in'
  rename { file -> 'Dockerfile' }
  expand(project.getProperties())
}

task rmDockerfile(type: Delete) {
    delete 'Dockerfile'
}

task distDocker {
    doLast {
        def start = new Date()
        def directory = project.buildscript.sourceFile.getParentFile()
        def cmd = dockerBinary + dockerBuildArg
        if (dockerArch) {
          //  See whether there's an architecture-specific Dockerfile in place
          def f = new File(directory.getAbsolutePath(), "Dockerfile."+dockerArch);
          if (f.exists()) {
            cmd += ['-f', f.getAbsolutePath()]
          }
        }
        cmd += ['-t', dockerImageName, directory.getAbsolutePath()]
        retry(cmd, dockerRetries, dockerTimeout)
        println("Building '${dockerImageName}' took ${TimeCategory.minus(new Date(), start)}")
    }
}

if (file("Dockerfile.in").exists()) {
  distDocker.dependsOn 'templateDockerfile'
  distDocker.finalizedBy 'rmDockerfile'
}

task tagImage {
    doLast {
        def versionString = (dockerBinary + ['-v']).execute().text
        def matched = (versionString =~ /(\d+)\.(\d+)\.(\d+)/)

        def major = matched[0][1] as int
        def minor = matched[0][2] as int

        def dockerCmd = ['tag']
        if(major == 1 && minor < 12) {
            dockerCmd += ['-f']
        }
        retry(dockerBinary + dockerCmd + [dockerImageName, dockerTaggedImageName], dockerRetries, dockerTimeout)
    }
}

task pushImage {
    doLast {
        def cmd = dockerBinary + ['push', dockerTaggedImageName]
        retry(cmd, dockerRetries, dockerTimeout)
    }
}
pushImage.dependsOn tagImage
pushImage.onlyIf { dockerRegistry != '' }
distDocker.finalizedBy pushImage

def retry(cmd, retries, timeout) {
    println("${new Date()}: Executing '${cmd.join(" ")}'")
    def proc = cmd.execute()
    proc.consumeProcessOutput(System.out, System.err)
    proc.waitForOrKill(timeout * 1000)
    if(proc.exitValue() != 0) {
        def message = "${new Date()}: Command '${cmd.join(" ")}' failed with exitCode ${proc.exitValue()}"
        if(proc.exitValue() == 143) { // 143 means the process was killed (SIGTERM signal)
            message = "${new Date()}: Command '${cmd.join(" ")}' was killed after ${timeout} seconds"
        }

        if(retries > 1) {
            println("${message}, ${retries-1} retries left, retrying...")
            retry(cmd, retries-1, timeout)
        }
        else {
            println("${message}, no more retries left, aborting...")
            throw new GradleException(message)
        }
    }
}
